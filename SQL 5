大家好，欢迎阅读金猪Ethan的SQL小课堂。虽说是SQL小课堂，但其实是梳理自己的SQL做题笔记，理清思路，加深记忆，欢迎跟我一起学习。

今天的题目是力扣1949.Strong Friendship，题目给了我们一张表，两个列，user1_id，user2_id，代表这两个列之间为好朋友，并且user1_id < user2_id永远成立。题目让我们找出Strong Friendship，即user1_id，user2_id至少存在三个以上的共同好友。tim 题目例子如下：


首先最重要的，先要搞明白的问题是，我们怎么找到共同好友，举个例子：

我叫1，我比较孤僻，只有两个好朋友，2和3，这个2也有自己的交际圈，他有好朋友3，4，5，6，7等等数不胜数，那么对于我（1）来说，这个3就是我1和2的共同好友。

明确了共同好友的定义和寻找方法，我们大致会有一个思路：

比如我是user1_id为1这个人，

第一步：先找出我的所有朋友，这个简单，直接在原表中就有。

第二步，找出所有以我为共同好友的两个人的两两组合，意思就是说，有哪两个人把我当作共同好友，上述例子中3就是我1和2的共同好友，那么我（1）就是2和3两个人的共同好友。

第三步，在第二步的基础上，找出这些以我（1)为共同好友的人（比如2）他们各自的好朋友，如果这个2的好朋友中存在同时是我的好朋友，那这个组合就是我们想要找出的结果，我们把我（1）和我的朋友（2）组合起来，绑定在一起，找出我们两个共同的好友，进行COUNT，满足这个COUNT的结果大于等于3，结果就出来了。

思路有了，那么我们直奔代码：


这个解法非常巧妙，用下图的部分：


将表格中的所有朋友关系列出来，比如2是我1的朋友，那么我1就是2的朋友。

以例子中的数据为例，通过这个方法我们得到了一个新表f如下图所示：


我们将f以user1_id进行分组并排序，方便后续理解，更新后的f如下图所示：


这样一来，所有的朋友关系就非常直观了，比如1的所有朋友是2，3，4，5，6，7，比如6的所有朋友是1，2，3等等。

接下来如何找到上文中的第二步，找出所有以我为共同好友的两个人的两两组合呢？很简单，我们将原表（命名为a）和这个新得到的表f根据user1_id进行merge，代码如下：


得到的结果如下，这是一个非常长的结果，因为只要满足a.user1_id = b.user1_id的records都会放在结果中。结果如下：




先忽略加绿部分，加绿部分后面会解释，这张图看起来很长很复杂，但给我们的信息很直观，很方便理解，比如我是1的话，这张表中就显示了所有以我为共同好友的两个人的两两组合，比如2，2（当然这两个2是同一个人，在后续的merge中会被删除）比如2，3比如2，4等等一直到7，7，这些两两组合都是以我为共同好友的两个人。同理，以2为共同好友的两个人。。。一直到以7为共同好友的两个人。

得到这张表之后，就开始进入结尾部分，怎么找到我（1）和我的朋友（2）的共同好友呢？既然我（1）的所有朋友组合都有了，那么同理只要得到2的所有朋友，跟我的朋友有交集即可。如何在第二步的基础上找到答案呢？

很简单，我们继续对这个“第一次JOIN 结果”再JOIN一次表f，按照ON a.user2_id = c.user1_id AND b.user2_id = c.user2_id进行JOIN。这个部分是整个答案中最tricky的部分，它想要表述的意思是，比如以我为出发点（即表a中的user1_id），我的朋友（即表a中的user2_id），再以我的朋友（即表a中的user2_id）为出发点，即我的朋友本身为参照系，那么就从“表a中的user2_id”变成“表c中的user1_id”，那么我的朋友的朋友是谁呢？是不是就是“表c中的user2_id”？那么只要我的朋友（即表a中的user2_id）和我的朋友的朋友（表c中的user2_id）相等，那岂不是就是我和我的朋友的共同好友了呢？这就是答案中ON a.user2_id = c.user1_id AND b.user2_id = c.user2_id的由来。

最后揭晓绿色部分，这个部分就是所有满足上一步的结果，即所有两两朋友的共同好友关系，所有共同好友涉及到三个人的关系，所以这个结果部分有三列。整理一下得到如下merge后的结果：


然后找出绑定我和我的朋友，即GROUP BY a.user1_id, a.user2_id 满足HAVING COUNT(c.user2_id) >= 3的例子如下：


这里还有一个tricky的地方，为什么2，1和3，1没有被选择出来，这里是因为我们在GROUP BY a.user1_id, a.user2_id选择的是来自a表中的每一行records，最后选出来的结果SELECT a.user1_id, a.user2_id也是来自与a表中的records，在题目中已经定义了a表即原始表中始终满足user1_id < user2_id，所以最后的结果中也只包含user1_id < user2_id的结果。最终得到的结果如下：


触类旁通：

这是一道非常优秀的题目，在工作中也可能用到，这是我第一次使用UNION的方法将数据整合起来，同时连续两次merge也是对逻辑的考验，在做这样的题目时，一定要画图，一定要举例来方便自己理解。

谢谢阅读，请继续享受学习的过程。
