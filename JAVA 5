大家好，欢迎阅读金猪Ethan的JAVA小课堂。虽说是JAVA小课堂，但其实是梳理自己的JAVA做题笔记，理清思路，加深记忆，欢迎跟我一起学习。

今天的题目是力扣239 Sliding Window Maximum。看到红红的Hard，就知道这道题来者不善，作者本人看到之后就开始心里犯难，这玩意，能做的出来吗？我肯定又不会做？这玩意是人能做的出来的吗？如果你有相同的想法，这种想法很危险，生活中遇到其他难题大概率你会有同样的潜意识反应，我肯定又解决不了，这太难了，我太菜了，我是垃圾。如何克服这样的缺点，从失败的漩涡中走出来呢？

很简单，不断给自己鼓劲，打气，告诉自己，洗脑自己，你很强，这道题很弱，你很聪明，你必然能解决，不断训练你的潜意识，告诉自己强无敌，眼前的题目，眼前的困难，眼前的挑战，不值一提，你就是最强的。当然，也要有心理准备，做好承受解不出题目的苦涩境地。相信我，延迟满足之后，豁然开朗的结果能让你真实地感受到人间的快乐，和一部分人生的意义。这比吃喝玩乐的快乐要美好更多。

来看题，给了一个整数数组nums，给了一个滑动的窗口，长度为k，从数组nums的最左边滑动到最右边，每一次滑动过程中我们只能看到窗口内k个数字，每一次滑动窗口向右移动一位，我们需要返回每一次滑动得到的k个数中的最大值，并将这些最大值组合起来得到一个新的数组并返回。

比如下面这个例子：


看到题目我们可以暴力求解，但更好的方法是使用Deque，这里顺带复习一遍Deque，Deque是一个可以在两端进行增查改删的线性集合linear collection，常用的方法如下：


针对本题，我们需要使用一个单调递减队列Monotonic Decreasing Queue的Deque方法，就是在每一次添加过程中，如果新加入的元素比之前存在的顶格最后一个元素更大，那么之前的顶格元素就会被pop出去，新加入的元素会放进去，如果新加入的元素比之前存在的顶格最后一个元素更小，那么之前的不做改动，新加入的元素同样会放进去，这样的结果是，这个队列从前到后，从左到右，始终能保持是由大到小单调递减的。

在拥有以上的背景知识之后，这道题就有了思路，我们用一个index i遍历一遍整个数组，同时创建一个Monotonic Decreasing Queue/Deque，每一次把一个数字加到Deque，但加入之前，我们判断一下这个新加入的数字是否比之前加入的数字更大，如果是的话，就把前面小的数字剔除，把这个新的较大的数字加入到Deque中，如此一来，不断循环，到最后我们就会找到每一次过程中的最大值。这个方法的好处是，前面较小的数字如果包含在这个窗口中，我们就不需要考虑了，同时每一次添加或者删除的时间复杂度是O(1)，整个数组遍历一遍的整体复杂度可以达到O(n)这个结果是非常可观的。

那么我们直接看代码：


再一次感谢第一个写出这个代码的神人，你真的是神，yyds。

接下来推敲一些细节：

如果得到的是空的数组，或者k小于等于0怎么办，我们直接输出return new int[0];
结果数组的长度是多少，从例子中我们可以看到长度是n+1-k
如何创建Deque：Deque<Integer> q = new ArrayDeque<>();
如何保证每一次考虑范围在k这个窗口之内呢？下面这个while可以保证在窗口左侧的所有数字都会被poll干净
while(!q.isEmpty() && q.peek()<i-k+1){
q.poll();
}
另外一个注意的点，我们在Deque q中存储的是index i，这个i用来帮助我们遍历数组，同时也用来帮我们用4中提到的方法限定窗口的范围
因为Deque是从大到小，那么我们添加进去的较小的数字怎么办？如下方法是将所有比当下数字nums[i]全部破poll干净的方法，这些较小的数字我们不会考虑。
while(!q.isEmpty() && nums[q.peekLast()] < nums[i]){
q.pollLast();
}
经过以上筛选，剩下的每一次窗口中最大的数字通过Deque帮助我们筛选出来，我们将结果保存在创建的数组r中。
整个题目确实有挑战性，想出时间复杂度为O(1)的解法真的是令人赞叹。

触类旁通，所有需要返回数组最大值的题目都可以尝试使用Deque这个已经非常成熟的解法来解决。

谢谢阅读，请继续享受学习的过程。
